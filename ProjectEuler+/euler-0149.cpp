// ////////////////////////////////////////////////////////
// # Title
// Searching for a maximum-sum subsequence
//
// # URL
// https://projecteuler.net/problem=149
// http://euler.stephan-brumme.com/149/
//
// # Problem
// Looking at the table below, it is easy to verify that the maximum possible sum of adjacent numbers in any direction
// (horizontal, vertical, diagonal or anti-diagonal) is 16 (= 8 + 7 + 1).
//
// ||  2 ||  2 ||  2 ||  2 ||
// || -2 ++  5 ++  3 ++  2 ||
// ||  9 ++ -6 ++  5 ++  1 ||
// ||  3 ++  2 ++  7 ++  3 ||
// || -1 ++  8 ++ -4 ++  8 ||
//
// Now, let us repeat the search, but on a much larger scale:
//
// First, generate four million pseudo-random numbers using a specific form of what is known as a "Lagged Fibonacci Generator":
//
// For  `1 <= k <= 55`, `s_k = [100003 - 200003k + 300007k^3] mod 1000000 - 500000`.
// For `56 <= k <= 4000000`, `s_k = [s_{k-24} + s_{k-55} + 1000000] mod 1000000 - 500000`.
//
// Thus, `s_10 = -393027` and `s_100 = 86613`.
//
// The terms of `s` are then arranged in a 2000x2000 table, using the first 2000 numbers to fill the first row (sequentially),
// the next 2000 numbers to fill the second row, and so on.
//
// Finally, find the greatest sum of (any number of) adjacent entries in any direction (horizontal, vertical, diagonal or anti-diagonal).
//
// # Solved by
// Stephan Brumme
// May 2017
//
// # Algorithm
// The basic problem is known as "Kadane's algorithm", see here: https://en.wikipedia.org/wiki/Maximum_subarray_problem .
// In one dimension it does the following:
// 1. assume that the first element is the best sum
// 2. add consecutive elements and check every time:
// - does the current sum exceed the previously best sume ? if yes, replace it
// - is the sum negative ? if yes, reset it to zero
// Especially the second condition wasn't obvious to me - even though it makes sense, when you think a second about it.
//
// All random numbers are generated by ''fillLaggedFibonacciSequence'' and stored in ''data'' which is a one-dimensional array.
// ''index'' converts a 2D coordinate to a unique 1D position inside ''data''.
//
// ''maxSum'' implements Kadane's algorithm: it analyzed all elements from ''data[first]'' to ''data[last]'' that are ''increment'' steps apart.
// - if ''maxSum'' should analyze all numbers of a row, then ''increment'' is 1
// - if ''maxSum'' should analyze all numbers of a column, then ''increment'' is the matrix's width (''size = 2000'').
// - if ''maxSum'' should analyze all numbers of a diagonal from the top-left to the bottom-right, then ''increment'' is the matrix's width plus one
// - if ''maxSum'' should analyze all numbers of a diagonal from the top-right to the bottom-left, then ''increment'' is the matrix's width minus one
//
// # Note
// You don't need to scan the diagonals because they don't contain the maximum sum in this particular case ...
// I used a bit of weird pointer arithmetic in ''fillLaggedFibonacciSequence''. It's been a long times since I needed negative indices !
//
// # Alternative
// In comparison to other problems, this is a pretty memory-consuming solution.
// When adding a bit of extra logic you don't need to store the whole matrix - just the current row is enough if you update your sums accordingly.

#include <iostream>
#include <vector>

// 2000x2000 matrix
const size_t size = 2000;
int* data = NULL;

// find maximum sum of all elements from data[first] to data[last]
int maxSum(size_t first, size_t last, size_t increment)
{
  // Kadane's algorithm
  // https://en.wikipedia.org/wiki/Maximum_subarray_problem
  int result = data[first];
  int currentSum = 0;
  for (auto i = first; i <= last; i += increment)
  {
    // "extend" current sum
    currentSum += data[i];

    // if sum is negative then there must be single element bigger or equal
    // which is already stored in result
    if (currentSum < 0)
      currentSum = 0;

    // improved sum ?
    if (result < currentSum)
      result = currentSum;
  }

  return result;
}

// fill 2000x2000 matrix
void fillLaggedFibonacciSequence()
{
  // fill elements in consecutive order
  int *current = data;

  // initial 55 elements
  long long k = 1; // note: if only int is used, then k*k*k overflows !
  while (k <= 55)
  {
    *current++ = ((100003 - 200003 * k + 300007 * k*k*k) % 1000000) - 500000;
    k++;
  }
  // ... to infinity and beyond !
  while (current < data + size*size)
    *current++ = ((current[-24] + current[-55] + 1000000) % 1000000) - 500000;
}

// convert 2D coordinate to a linear 1D coordinate
size_t index(size_t x, size_t y)
{
  return y * size + x;
}

int main()
{
  // allocate memory
  data = new int[size*size];
  // generate sequence
  fillLaggedFibonacciSequence();

  auto last = size - 1;
  auto result = data[0];

  // horizontal
  for (size_t y = 0; y <= last; y++)
  {
    auto current = maxSum(index(0, y), index(last, y), 1);
    if (result < current)
      result = current;
  }

  // vertical
  for (size_t x = 0; x <= last; x++)
  {
    auto current = maxSum(index(x, 0), index(x, last), size);
    if (result < current)
      result = current;
  }

  // diagonal \ => from upper to right edge
  for (size_t x = 0; x <= last; x++)
  {
    auto current = maxSum(index(x, 0), index(last, last - x), size + 1);
    if (result < current)
      result = current;
  }

  // diagonal \ => from left to lower edge
  for (size_t y = 1; y <= last; y++) // y = 0 was already checked by previous loop
  {
    auto current = maxSum(index(0, y), index(y, last), size + 1);
    if (result < current)
      result = current;
  }

  // diagonal / => from upper to left edge
  for (size_t x = 0; x <= last; x++)
  {
    auto current = maxSum(index(x, 0), index(0, x), size - 1);
    if (result < current)
      result = current;
  }

  // diagonal / => from right to lower edge
  for (size_t y = 1; y <= last; y++) // y = 0 was already checked by previous loop
  {
    auto current = maxSum(index(last, y), index(y, last), size - 1);
    if (result < current)
      result = current;
  }

  std::cout << result << std::endl;
  delete[] data;

  return 0;
}
