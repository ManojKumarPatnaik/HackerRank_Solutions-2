// ////////////////////////////////////////////////////////
// # Title
// B&eacute;zier Curves
//
// # URL
// https://projecteuler.net/problem=363
// http://euler.stephan-brumme.com/363/
//
// # Problem
// A cubic B&eacute;zier curve is defined by four points: `P_0`, `P_1`, `P_2` and `P_3`.
//
// The curve is constructed as follows:
// On the segments `P_0 P_1`, `P_1 P_2` and `P_2 P_3` the points `Q_0`, `Q_1` and `Q_2` are drawn such that
// `P_0 Q_0 / P_0 P_1 = P_1 Q_1 / P_1 P_2 = P_2 Q_2 / P_2 P_3 = t` (`t` in `[0,1]`).
// On the segments `Q_0 Q_1` and `Q_1 Q_2` the points `R_0` and `R_1` are drawn such that
// `Q_0 R_0 / Q_0 Q_1 = Q_1 R_1 / Q_1 Q_2 = t` for the same value of `t`.
// On the segment `R_0 R_1` the point `B` is drawn such that `R_0 B / R_0 R_1 = t` for the same value of `t`.
// The B&eacute;zier curve defined by the points `P_0`, `P_1`, `P_2` and `P_3` is the locus of `B` as `Q_0` takes all possible positions on the segment `P_0 P_1`.
// (Please note that for all points the value of `t` is the same.)
//
// ![bezier](p363_bezier.png)
//
// At [this (external) web address](http://home.kpn.nl/hklein/bezier/bezier.html) you will find an applet that allows you to drag the points `P_0`, `P_1`, `P_2` and `P_3`
// to see what the Bezier curve (green curve) defined by those points looks like.
// You can also drag the point `Q_0` along the segment `P_0 P_1`.
//
// From the construction it is clear that the B&eacute;zier curve will be tangent to the segments `P_0 P_1` in `P_0` and `P_2 P_3` in `P_3`.
//
// A cubic B&eacute;zier curve with `P_0=(1,0)`, `P_1=(1,v)`, `P_2=(v,1)` and `P_3=(0,1)` is used to approximate a quarter circle.
// The value `v > 0` is chosen such that the area enclosed by the lines `O P_0`, `O P_3` and the curve is equal to `pi/4` (the area of the quarter circle).
// By how many percent does the length of the curve differ from the length of the quarter circle?
// That is, if `L` is the length of the curve, calculate `100 * dfrac{L - pi/2}{pi/2}`
//
// Give your answer rounded to 10 digits behind the decimal point.
//
// # Solved by
// Stephan Brumme
// September 2017
//
// # Algorithm
// I implemented a generic ''bezier()'' function which returns a 2D point interpolated between four B&eacute;zier points.
// It relies on the deCasteljau algorithm (see https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm ).
//
// A bit more accurate and much faster is ''bezierArc'' which assumes that the four B&eacute;zier points are `(1, 0)`, `(1, v)`, `(v, 1)`, `(0, 1)`.
// When these four points are substituted in the formulas for cubic B&eacute;zier curves (see https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves ) then they simplify to:
// (1) `B(t) = (1-t)^3 P_0 + 3(1-t)^2 t P_1 + 3(1-t) t^2 P_2 + t^3 P_3`
// (2) `x(t) = (1 - t)^3 + 3(1-t)^2t + 3(1-t) t^2 v`
// (3) `y(t) = 3(1-t)^2tv + 3(1-t) t^2 + t^3`
//
// `v` is unknown and `0 <= t <= 1`.
// My program initially assumes that ''v = 0.5'' and tries to gradually improve that value (see ''#ifdef FIND_V''):
// - a loop iterates `t` from zero to one with ''StepT = 0.000001'' (that's a million steps)
// - the resulting area of the B&eacute;zier curve is compared against the area of the quarter circle
// - if the B&eacute;zier curve's area is smaller then `v` is slightly incremented (and if the area is too big then `v` is decremented)
//
// After a sufficient number of iterations `v` should converge to the correct value.
// But no matter what I tried, I got pretty close but couldn't solve this problem. I couldn't find a better result than a 0.000000122206% deviation from the quarter circle which is wrong.
// (if you optimize the constants ''StepT'' and ''AreaAccuracy'' you might find slightly better value but most likely not the correct one).
//
// Then I went down the dirty road and asked Wolfram Alpha to solve the integral `integral{y * dfrac{\delta x}{\delta t} dt} = dfrac{pi}{4}`
// http://www.wolframalpha.com/input/?i=Integrate%5B(3(1-t)%5E2tv%2B3(1-t)t%5E2%2Bt%5E3)+D%5B(1-t)%5E3%2B3(1-t)%5E2t%2B3((1-t)t%5E2v),t%5D,+%7Bt,+0,+1%7D%5D+%3D+pi%2F4
//
// It displayed
// (4) `-dfrac{3v^2}{20}+dfrac{3v}{5}+dfrac{1}{2}=dfrac{pi}{4}`
//
// (5) `v = 2 \pm sqrt{dfrac{22 - 5 pi}{3}}`
//
// There are two solutions for `v`. One is pretty close to what my program converged to, the other solution is far, far away and can be ignored:
// `v_1 = 3.448221522195532282154562592704972836349668711`
// `v_2 = 0.551778477804467717845437407295027163650331289` ==> that matches my approximation `0.5517813930`
//
// I tried to continue with Wolfram Alpha but lost interest when I saw the weird integrals generated by it.
// Nevertheless, those were my ideas (for the sake of completeness):
// Wikipedia tells me that the length `L` of an arc is (see https://en.wikipedia.org/wiki/Arc_length ):
// (6) `L = integral{1 + (dfrac{dy}{dx})^2} dx`
//
// Equations (2) and (3) together with the exact result (`v_2`):
//
// (7) `x(t) = (1 - t)^3 + 3(1-t)^2t + 3(1-t) t^2 (2 - sqrt{dfrac{22 - 5 pi}{3}})`
//
// (8) `y(t) = 3(1-t)^2t (2 - sqrt{dfrac{22 - 5 pi}{3}}) + 3(1-t) t^2 + t^3`
//
// As mentioned before, Wolfram Alpha will find the correct result.
//
// Well, back to my solution:
// using the correct `v` I can recursively compute the length of the B&eacute;zier curve using an epsilon:
// - ''getLength()'' computes the length of a line between `v_{from}` and `v_{to}`
// - then it computes the sum of the lengths of the two lines `v_{from}`,`v_{(from+to)/2}` and `v_{(from+to)/2}`,`v_{to}`
// - if the sum of those two shorter lines differs more than ''epsilon'' from the original line then I recursively compute a more accurate length of those two shorter lines
// That approach is surprisingly fast - the main obstacle was to find a proper ''epsilon'' (I settled with `10^-17`).
//
// # Alternative
// [Meng-Gen Tsai](https://github.com/Meng-Gen/ProjectEuler/blob/master/363.txt) solved the whole problem with Wolfram Alpha despite all the ugly integrals.
//
// I could have integrated equations (7) and (8) numerically (instead of writing ''getLength()'').
//
// # Note
// There is no live test.
//
// My personal view on this problem: I have a background in Computer Graphics and really like B&eacute;zier curves.
// After having solved this weird problem, I'm not sure whether I still like B&eacute;zier curves anymore.
// This problem changed a conceptually very simple technique (especially the very elegant de Casteljau's algorithm) into something full of meaningless integrals.
// It took all the beauty out of it. That's sad !

#include <iostream>
#include <iomanip>
#include <cmath>

typedef double Number; // changing it to long double gives the same results

// 2D point
struct Point
{
  // create a new point
  Point(Number x_, Number y_)
  : x(x_), y(y_) {}

  // return distance between two points
  Number distance(const Point& other) const
  {
    auto diffX = x - other.x;
    auto diffY = y - other.y;
    return sqrt(diffX * diffX + diffY * diffY);
  }

  Number x, y;
};

// interpolate between four points p0, p1, p2, p3 with parameter t
Point bezier(const Point& p0, const Point& p1, const Point& p2, const Point& p3, Number t)
{
  // see https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm

  // linear interpolation between p0 and p1, p1 and p2, p2 and p3
  Point q0(p0.x + (p1.x - p0.x) * t, p0.y + (p1.y - p0.y) * t);
  Point q1(p1.x + (p2.x - p1.x) * t, p1.y + (p2.y - p1.y) * t);
  Point q2(p2.x + (p3.x - p2.x) * t, p2.y + (p3.y - p2.y) * t);

  // rinse and repeat: linear interpolation between q0 and q1, q1 and q2
  Point r0(q0.x + (q1.x - q0.x) * t, q0.y + (q1.y - q0.y) * t);
  Point r1(q1.x + (q2.x - q1.x) * t, q1.y + (q2.y - q1.y) * t);

  // and finally: linear interpolation between q0 and q1, q1 and q2
  Point b(r0.x + (r1.x - r0.x) * t, r0.y + (r1.y - r0.y) * t);

  return b;
}

// same as bezier() but optimized for the case (1, 0), (1, v), (v, 1), (0, 1)
Point bezierArc(Number v, Number t)
{
  // direct computation of cubic Bezier curves (see https://en.wikipedia.org/wiki/B%C3%A9zier_curve ):
  // replace p0,p1,p2,p3 by their known values 0, 1 or v
  return Point(pow(1 - t, 3) + 3*pow(1 - t, 2)*t   + 3*(1 - t)*t*t*v,
                               3*pow(1 - t, 2)*t*v + 3*(1 - t)*t*t   + t*t*t);
}

// find length of Bezier curve between t=from and t=to with an accuracy=epsilon
Number getLength(Number v, Number from, Number to, Number epsilon)
{
  // compute three points: start, middle and end
  auto bisect = (from + to) / 2;
  auto start  = bezierArc(v, from);
  auto middle = bezierArc(v, bisect);
  auto end    = bezierArc(v, to);

  // compute distance start,end against start,middle + middle,end
  auto totalDistance = start.distance(end);
  auto firstHalf     = middle.distance(start);
  auto secondHalf    = middle.distance(end);
  auto morePrecise   = firstHalf + secondHalf;
  // enough accuracy ?
  if (morePrecise < totalDistance + epsilon)
    return morePrecise;

  // go deeper, compute start,middle + start,end more accurately
  return getLength(v, from, bisect, epsilon) + getLength(v, bisect, to, epsilon);
}

int main()
{
  std::cout << std::fixed << std::setprecision(10);

  // some pi-based constants
  const Number pi     = 3.14159265358979323846264338327950288419;
  // expected length of the arc
  const Number piDiv2 = pi / 2;

  // find v
  Number v = 0.5;

//#define FIND_V
#ifdef  FIND_V
  // expected area inside the arc
  const Number piDiv4 = pi / 4;
  // carefully adjust tolerance thresholds
  const Number AreaAccuracy = 0.0000000001;
  const Number StepT        = 0.000001;

  // initial adjustment of v, will become smaller after a few iterations
  Number step = 0.01;
  // true when adding "step" to "v", false when subtracting
  bool increment = true;

  while (fabs(area - piDiv4) > AreaAccuracy)
  {
    Point last(1,0);
    Number area = 0;
    for (Number t = 0; t <= 1; t += StepT)
    {
      //Point p0(1, 0);
      //Point p1(1, v);
      //Point p2(v, 1);
      //Point p3(0, 1);
      //auto current = bezier(p0, p1, p2, p3, t);

      // optimized (=> faster) code
      auto current = bezierArc(v, t);

      // "last" is on the right side of "current": last.x > current.x
      auto diffX = last.x - current.x;
      auto diffY = last.y - current.y;
      area += current.y * diffX;
      last  = current;
    }

    // reduce deviation by adjusting v
    if (area < piDiv4)
    {
      // change direction ? reduce "step"
      if (!increment)
      {
        step /= 2;
        increment = true;
      }

      // increase v
      v += step;
    }
    else
    {
      // change direction ? reduce "step"
      if (increment)
      {
        step /= 2;
        increment = false;
      }

      // decrease v
      v -= step;
    }
  }
  std::cout << "v=" << v << std::endl;
#endif

  // pretty exact value of v
  v = 0.551778477804467717845437407295027163650331289;

  // compute length of the arc
  auto epsilon = 0.00000000000000001; // found manually (I tried several values until error stabilized)
  auto length = getLength(v, 0, 1, epsilon);
  auto error  = 100 * (length - piDiv2) / piDiv2;
  std::cout << error << std::endl;
  return 0;
}
