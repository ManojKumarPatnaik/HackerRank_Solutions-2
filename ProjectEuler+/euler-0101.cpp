// ////////////////////////////////////////////////////////
// # Title
// Optimum polynomial
//
// # URL
// https://projecteuler.net/problem=101
// http://euler.stephan-brumme.com/101/
//
// # Problem
// If we are presented with the first `k` terms of a sequence it is impossible to say with certainty the value of the next term,
// as there are infinitely many polynomial functions that can model the sequence.
//
// As an example, let us consider the sequence of cube numbers. This is defined by the generating function,
// `u_n = n^3`: 1, 8, 27, 64, 125, 216, ...
//
// Suppose we were only given the first two terms of this sequence. Working on the principle that "simple is best" we should assume a linear relationship
// and predict the next term to be 15 (common difference 7). Even if we were presented with the first three terms, by the same principle of simplicity, a quadratic relationship should be assumed.
//
// We shall define `OP(k, n)` to be the nth term of the optimum polynomial generating function for the first `k` terms of a sequence.
// It should be clear that `OP(k, n)` will accurately generate the terms of the sequence for `n <= k`, and potentially the first incorrect term (FIT) will be `OP(k, k+1)`;
// in which case we shall call it a bad OP (BOP).
//
// As a basis, if we were only given the first term of sequence, it would be most sensible to assume constancy; that is, for `n >= 2`, `OP(1, n) = u_1`.
//
// Hence we obtain the following OPs for the cubic sequence:
// `OP(1, n) = 1`
// 1, __1__, 1, 1, ...
//
// `OP(2, n) = 7n-6`
// 1, 8, __15__, ...
//
// `OP(3, n) = 6n^2-11n+6`
// 1, 8, 27, __58__, ...
//
// `OP(4, n) = n^3`
// 1, 8, 27, 64, 125, ...
//
// Clearly no BOPs exist for `k >= 4`.
// By considering the sum of FITs generated by the BOPs (indicated in __bold__ above), we obtain 1 + 15 + 58 = 74.
//
// Consider the following tenth degree polynomial generating function:
// `u_n = 1 - n + n^2 - n^3 + n^4 - n^5 + n^6 - n^7 + n^8 - n^9 + n^10`
//
// Find the sum of FITs for the BOPs.
//
// # Solved by
// Stephan Brumme
// May 2017
//
// # Algorithm
// When I read this problem, I didn't know anything about polynomial interpolation - and started reading the Wikipedia page: https://en.wikipedia.org/wiki/Polynomial_interpolation
// The [Lagrange polynomial](https://en.wikipedia.org/wiki/Lagrange_polynomial) caught my attention but my implementation just couldn't find the correct solution.
// Then I tried the [Newton polynomial](https://en.wikipedia.org/wiki/Newton_polynomial) and succeeded. Even more, I was able to fix the off-by-one error in my Lagrange code ...
//
// Nevertheless, I kept both routines in my solution. They return the same result.
//
// # Hackerrank
// [TODO] I modified my code to accept arbitrary coefficients for the polynomial generating function (originally ''{ +1, -1, +1, -1, +1, -1, +1, -1, +1, -1, +1 }'')
// but still fail to solve anything else than the default input.

//#define ORIGINAL

#include <iostream>
#include <vector>

// compute sum(coeff[i] * x^i)
template <typename T>
T sequence(T x, const std::vector<T>& coefficients)
{
  T xx = 1;
  T result = 0;
  for (auto i : coefficients)
  {
    result += i * xx;
    xx *= x;
  }
  return result;
}

// given f(1),f(2),f(3),...f(n) then find f(n+1)
// (Lagrange polynomials)
template <typename T>
T lagrange(const std::vector<T>& known)
{
  T result = 0;

  size_t next = known.size() + 1;
  for (size_t i = 1; i < next; i++)
  {
    // build Lagrange polynomials

    // n = numerator, d = denominator
    T n = 1;
    T d = 1;
    for (size_t j = 1; j < next; j++)
    {
      if (i == j)
        continue;

      n *= next - j;
      d *= i - j;
    }

    // evaluate
    result += known[i - 1] * (n / d);
  }
  return result;
}

// given f(1),f(2),f(3),...f(n) then find f(n+1)
// (Newton divided differences)
template <typename T>
T newton(std::vector<T> known)
{
  T result = known[0];

  size_t j = 1;
  size_t k = known.size();
  for (size_t last = known.size() - 1; last > 0; last--)
  {
    for (size_t i = 0; i < last; i++)
      known[i] = (known[i + 1] - known[i]) / j;

    T multDiff = 1;
    for (size_t i = 0; i < j; i++)
      multDiff *= k - i;

    result += known[0] * multDiff;
    j++;
  }

  return result;
}

int main()
{
  // read coefficients
#ifdef ORIGINAL
  std::vector<long long> coefficients = { +1, -1, +1, -1, +1, -1, +1, -1, +1, -1, +1 };
#else
  size_t numCoefficients;
  std::cin >> numCoefficients;
  std::vector<long long> coefficients(numCoefficients + 1);
  for (auto& i : coefficients)
    std::cin >> i;
#endif

  long long sum = 0;
  std::vector<long long> data;
  // iterate over 10 points
  for (long long x = 1; x < (long long)coefficients.size(); x++)
  {
    // add the next point
    data.push_back(sequence(x, coefficients));

    // estimate next point
    long long next = lagrange(data);
    //long long next = newton(data);
    sum += next;

#ifndef ORIGINAL
    std::cout << (next % 1000000007) << " ";
#endif
  }
#ifdef ORIGINAL
  std::cout << sum << std::endl;
#endif

  return 0;
}
