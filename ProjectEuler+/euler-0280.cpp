// ////////////////////////////////////////////////////////
// # Title
// Ant and seeds
//
// # URL
// https://projecteuler.net/problem=280
// http://euler.stephan-brumme.com/280/
//
// # Problem
// A laborious ant walks randomly on a 5x5 grid. The walk starts from the central square.
// At each step, the ant moves to an adjacent square at random, without leaving the grid; thus there are 2, 3 or 4 possible moves at each step depending on the ant's position.
//
// At the start of the walk, a seed is placed on each square of the lower row. When the ant isn't carrying a seed and reaches a square of the lower row containing a seed,
// it will start to carry the seed. The ant will drop the seed on the first empty square of the upper row it eventually reaches.
//
// What's the expected number of steps until all seeds have been dropped in the top row?
// Give your answer rounded to 6 decimal places.
//
// # Solved by
// Stephan Brumme
// August 2017
//
// # Algorithm
// Wow, this turned out to be one of my solution with the most code written exclusively for a single problem (there are longer ones which copy stuff like Miller-Rabin test from my toolbox) !
// But don't be afraid, it wasn't a hard problem, just lot's of laborous typing.
//
// I created a struct named ''State'' which contains:
// - the position of the ant (5x5 grid ==> 25 positions)
// - whether the ant currently carries a seed or not
// - the seeds in the top row
// - the seeds in the bottom row
// - a hash function ''State::getHash'' to uniquely identify a state
//
// A state implies that the seed was already dropped or picked up on the current square if possible.
// Not all states are valid, e.g. if the ant still carries a seed, is in the top row and the current square is empty (because the ant should have dropped the seed).
// A total of 10270 valid states remains (see ''State::isValid'').
//
// A state is final, if the top row contains enough seeds (= 5 seeds).
// My program determines how long it takes to reach a final state (there are 5 final states depending on where the last seed was dropped):
// `= 1 * p(1) + 2 * p(2) + 3 * p(3) + ... + n * p(n) + ...`
// `p(n)` is the probability that a final state is reached after exactly `n` moves.
// After a certain number of moves the probability rapidly approaches zero and then I abort (e.g. ignoring ridicilously low values such as `10^99 * p(10^99)` that are possible but extremely unlikely).
//
// The first initialization phase enumerates all valid states and stores them in ''states''.
// Then for each state I analyze whether it is final (stored in ''final'') or find all possible moves (up, down, left, right) and store them in ''transitions''.
//
// The actual computation of all moves can be written in just a few lines of code (see below the ''initialization is complete'' marker'').
// All states are initialized with probability zero, except for the initial state with is 1 (=100%), i.e. ant in the middle of the grid.
// Then do repeatedly:
// - for each state ''s'' there are up to 4 transitions, all equally likely, so the chance for each is ''1 / transitions[s].size()''
// - ''last[s]'' contains the probability to be in state ''s'' after exactly the current number of steps (''iteration'')
// - then ''next[t]'' will be the probability to be in state ''t'' after one more step
// - so for each transition from ''s'' to ''t1'', ''t2'', etc.: ''next[t] += last[s] / transitions[s].size()''
//
// After each iteration I add the probabilities that a final state was reached and add all of them.
// If the delta becomes very small, then I abort and print the current sum.
//
// # Note
// My live test allows to specify the number of seeds in a final state. For example if the ant needs to move only one seed to the top row, then it takes about 55.6 moves.
// However, my ''Epsilon'' was fine-tuned for the default case (5 seeds), so the last digits of the result might be slightly off.
//
// The ''transitions'' container was a ''std::map'' but memory allocations dominated execution time.
// Since my hash values are pretty close to each other (''maxHash = 49624'') I converted it to a sparse ''std::vector'' and the code became about 2x faster.

#include <iostream>
#include <iomanip>
#include <string>
#include <map>
#include <vector>
#include <bitset>

// 5x5 grid
const unsigned int gridSize = 5;
// how many seeds need to be transported from the bottom to the top row
unsigned int movedSeeds = 5;

// unique identifier of a state, generated by State::getHash()
typedef unsigned int Hash;

// note: all positions are zero-indexed, i.e. (0,0) to (4,4)
//       top row can be identified by y=0
struct State
{
  // ant's position
  unsigned int x;
  unsigned int y;
  // true if ant is currently carrying a seed
  bool carriesSeed;
  // true if seed at (x, 0)
  std::bitset<gridSize> seedsTopRow;
  // true if seed at (x, 4)
  std::bitset<gridSize> seedsBottomRow;

  // dummy constructor
  State() : x(0), y(0), carriesSeed(false), seedsTopRow(0), seedsBottomRow(0)
  {}

  // unique identifier
  Hash getHash() const
  {
    // 17 bits: xxxyyyctttttbbbbb
    Hash hash = carriesSeed ? 1 : 0;
    hash = (hash << seedsTopRow   .size()) + seedsTopRow   .to_ulong();
    hash = (hash << seedsBottomRow.size()) + seedsBottomRow.to_ulong();
    hash = hash * gridSize + x;
    hash = hash * gridSize + y;
    return hash;
  }

  // true if all seeds moved to top row
  bool isFinal() const
  {
    return seedsTopRow.count() == movedSeeds && !carriesSeed;
  }

  // return true if state has 5 seeds
  bool isValid() const
  {
    // ant can't carry a seed in top row if current square is empty
    if (y == 0 &&  carriesSeed && !seedsTopRow[x])
      return false;
    // ant can't be without a seed in bottom row if current square has seed
    if (y == gridSize - 1 && !carriesSeed &&  seedsBottomRow[x])
      return false;

    // if all seeds are in top row (final state) then the ant must be in the top row, too
    if (isFinal() && y != 0)
      return false;

    // a total of five seeds
    auto seeds = seedsTopRow.count() + seedsBottomRow.count();
    if (carriesSeed)
      seeds++;
    if (seeds != gridSize)
      return false;

    // all tests passed
    return true;
  }

  // convert to string (for debugging purposes only, not needed anymore)
  std::string toString() const
  {
    // position
    auto result = std::to_string(x) + "," + std::to_string(y);

    // flags
    if (isFinal())
      result += "!";
    else if (carriesSeed)
      result += "+";
    else
      result += " ";

    // seeds on the ground
    result += " ";
    for (size_t i = 0; i < seedsTopRow.size(); i++)
      result += std::to_string(seedsTopRow[i]);
    result += " ";
    for (size_t i = 0; i < seedsBottomRow.size(); i++)
      result += std::to_string(seedsBottomRow[i]);

    return result;
  }
};

int main()
{
  // how many seeds need to be transported from the bottom to the top row
  std::cin >> movedSeeds;

  std::cout << std::fixed << std::setprecision(6);

  // manually tuned threshold - exit computation if sufficient precision has been reached
  const double Epsilon = 0.0000000001;

  const auto AllBits = (1 << gridSize) - 1;

  // ant starts in the middle, all seeds in bottom row
  State initial;
  initial.x = 2;
  initial.y = 2;
  initial.carriesSeed    = false;
  initial.seedsTopRow    = 0;
  initial.seedsBottomRow = AllBits;

  // generate all states
  std::map<Hash, State> states;
  for (unsigned int x = 0; x < gridSize; x++)
    for (unsigned int y = 0; y < gridSize; y++)
      for (auto carriesSeed = 0; carriesSeed <= 1; carriesSeed++)
        for (auto maskTop = 0; maskTop <= AllBits; maskTop++)
          for (auto maskBottom = 0; maskBottom <= AllBits; maskBottom++)
          {
            // generate state
            State current;
            current.x = x;
            current.y = y;
            current.carriesSeed    = (carriesSeed == 1);
            current.seedsTopRow    = maskTop;
            current.seedsBottomRow = maskBottom;

            // only accept valid states
            if (!current.isValid())
              continue;

            // add to container
            states[current.getHash()] = current;
          }

  // find all transitions and identify final states
  std::map<Hash, std::vector<Hash>> transitions;
  std::vector<Hash> final;
  for (auto i : states)
  {
    auto current = i.second;

    // final state ?
    if (current.isFinal())
    {
      final.push_back(i.first);

      // no need to proceed after reaching a final state (no further moves of the ant)
      continue;
    }

    // and now some boring and repetitive code ...
    std::vector<State> candidates;

    // move up
    if (current.y > 0)
    {
      current.y--;
      candidates.push_back(current);
      current.y++; // restore
    }

    // move down
    if (current.y < gridSize - 1)
    {
      current.y++;
      candidates.push_back(current);
      current.y--; // restore
    }

    // move left
    if (current.x > 0)
    {
      current.x--;
      candidates.push_back(current);
      current.x++; // restore
    }

    // move right
    if (current.x < gridSize - 1)
    {
      current.x++;
      candidates.push_back(current);
      current.x--; // restore
    }

    // drop or pick up seed
    for (auto candidate : candidates)
    {
      // drop seed ?
      if ( candidate.carriesSeed &&
           candidate.y == 0      &&
          !candidate.seedsTopRow[candidate.x])
      {
        candidate.carriesSeed = false;
        candidate.seedsTopRow[candidate.x] = true;
      }

      // pick up seed ?
      if (!candidate.carriesSeed       &&
           candidate.y == gridSize - 1 &&
           candidate.seedsBottomRow[candidate.x])
      {
        candidate.carriesSeed = true;
        candidate.seedsBottomRow[candidate.x] = false;
      }

      // found one more state transition
      transitions[current.getHash()].push_back(candidate.getHash());
    }
  }

  // no valid moves
  if (final.empty() || transitions.empty())
    return 1;

  // get highest hash value
  auto maxHash = transitions.rbegin()->first;

  // ---------- initialization is complete, let's find the result ! ----------

  // initially the ant is with 100% probability in the middle of the grid
  std::vector<double> last(maxHash + 1, 0);
  for (auto x : states)
    last[x.first] = 0;
  last[initial.getHash()] = 1;

  // E = 1 * p(1) + 2 * p(2) + 3 * p(3) + ... + n * p(n)
  // where p(n) is the probability that a final state was reached after n steps
  double expected = 0;

  // run this loop until the variable "expected" changes less than Epsilon
  for (unsigned int iteration = 1; ; iteration++)
  {
    std::vector<double> next(last.size(), 0);
    for (const auto& followup : transitions)
    {
      auto      from = followup.first;  // a hash
      const auto& to = followup.second; // a container with hashes

      // each step is equally likely
      double probability = 1.0 / to.size();
      probability *= last[from];

      // add to each allowed follow-up state
      for (auto move : to)
        next[move] += probability;
    }

    // overwrite old probabilities with new values
    last = std::move(next);

    // add probabilities of reaching a final state
    double add = 0;
    for (auto x : final)
      add += last[x];

    // E = 1 * p(1) + 2 * p(2) + ...
    add *= iteration;
    expected += add;

    // enough precision ?
    if (add < Epsilon && expected > 1) // don't abort in the first iterations when add == 0 and expected == 0
      break;
  }

  // print result
  std::cout << expected << std::endl;
  return 0;
}
