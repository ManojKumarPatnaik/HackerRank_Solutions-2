// ////////////////////////////////////////////////////////
// # Title
// Zeckendorf Representation
//
// # URL
// https://projecteuler.net/problem=297
// http://euler.stephan-brumme.com/297/
//
// # Problem
// Each new term in the Fibonacci sequence is generated by adding the previous two terms.
// Starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89.
//
// Every positive integer can be uniquely written as a sum of nonconsecutive terms of the Fibonacci sequence.
// For example, 100 = 3 + 8 + 89.
// Such a sum is called the Zeckendorf representation of the number.
//
// For any integer `n>0`, let `z(n)` be the number of terms in the Zeckendorf representation of `n`.
// Thus, `z(5) = 1`, `z(14) = 2`, `z(100) = 3` etc.
// Also, for `0 < n < 10^6`, `sum{z(n)} = 7894453`.
//
// Find `sum{z(n)}` for `0 < n < 10^17`.
//
// # Solved by
// Stephan Brumme
// July 2017
//
// # Algorithm
// Often I write a simple brute-force program which produces the correct result for small inputs.
// The function ''zeckendorf'' returns the number of terms in the Zeckendorf representation of a single number.
// According to the Wikipedia page on the Zeckendorf theorem ( https://en.wikipedia.org/wiki/Zeckendorf%27s_theorem ) a greedy repeated search
// for the largest Fibonacci numbers <= the current number is sufficient.
//
// Then I printed the first 100 numbers (and their sum) and discovered the pattern:
// the number of terms repeats after each new Fibonacci number, abeit increased by one. For example:
//
// ||    4   ||          10            ||   5   ||      6      ||
// ||!number ++ ''zeckendorf(number)'' ++  sum  ++ ''fiboSum'' ||
// ||  __1__ ++           1            ++   1   ++      1      ||
// ||  __2__ ++           1            ++   2   ++      2      ||
// ||  __3__ ++           1            ++   3   ++      3      ||
// ||    4   ++           2            ++   5   ++      ~      ||
// ||  __5__ ++           1            ++   6   ++      6      ||
// ||    6   ++           2            ++   8   ++      ~      ||
// ||    7   ++           2            ++  10   ++      ~      ||
// ||  __8__ ++           1            ++  11   ++     11      ||
// ||    9   ++           2            ++  13   ++      ~      ||
// ||   10   ++           2            ++  15   ++      ~      ||
// ||   11   ++           2            ++  17   ++      ~      ||
// ||   12   ++           3            ++  20   ++      ~      ||
// || __13__ ++           1            ++  21   ++     21      ||
// ||   14   ++           2            ++  23   ++      ~      ||
// ||   15   ++           2            ++  25   ++      ~      ||
// ||   16   ++           2            ++  27   ++      ~      ||
// ||   17   ++           3            ++  30   ++      ~      ||
// ||   18   ++           2            ++  32   ++      ~      ||
// ||   19   ++           3            ++  35   ++      ~      ||
// ||   20   ++           3            ++  38   ++      ~      ||
// || __21__ ++           1            ++  39   ++     39      ||
//
// The Zeckendorf representation is always 1 for a Fibonacci number (which are __bold__ in the table above).
// My array ''fiboSum'' contains the running total (the sum) for each n-th Fibonacci number:
// ''fiboSum[n] = fiboSum[n - 1] + fiboSum[n - 2] + fibonacci[n - 2] - 1''
//
// Using that relationship my function ''search'' recursively subtracts the largest possible Fibonacci number
// while adding the relevant value ''fiboSum''.
//
// # Note
// The ''zeckendorf'' function isn't needed anymore but I didn't remove it because my gut tells me I could use it in the future ...

#include <iostream>
#include <vector>

// all Fibonacci numbers below 10^17
std::vector<unsigned long long> fibonacci;
// and the sum according to my algorithm description
std::vector<unsigned long long> fiboSum; // fibonacci.size() == fiboSum.size()

// see https://en.wikipedia.org/wiki/Zeckendorf%27s_theorem
// return the length of the Zeckendorf representation of x
unsigned int zeckendorf(unsigned long long x)
{
  unsigned int result = 0;

  // greedy search:
  // in each step subtract the largest possible Fibonacci number
  unsigned int pos = fibonacci.size() - 1;
  while (x > 0)
  {
    while (fibonacci[pos] > x)
      pos--;

    x -= fibonacci[pos];
    result++;
  }

  return result;
}

// compute sum of the length of all Zeckendorf representations from 1 to x
unsigned long long search(unsigned long long x)
{
  // find largest Fibonacci number <= x
  auto pos = 0;
  while (fibonacci[pos + 1] <= x)
    pos++;

  // strip off that Fibonacci number
  auto reduced = x - fibonacci[pos];

  // done ?
  if (reduced == 0)
    return fiboSum[pos];

  // still more 1s in the binary Zeckendorf representation left ...
  return fiboSum[pos] + reduced + search(reduced);
}

int main()
{
  unsigned long long limit = 100000000000000000ULL;
  std::cin >> limit;

  // note: it took me a while to figure out that because of F(1) = F(2) = 1
  //       I am not allowed to represent 3 as F(1) + F(3) (which is 3 = 1 + 2)
  //       even though F(1) and F(3) are not consecutive
  //       if I remove F(1) (or F(2)) then that ambiguity disappears and everything's fine

  // start with Fibonacci numbers F(2) and F(3)
  fibonacci = { 1, 2 };

  // F(2) has length 1, F(3) as length 1 as well plus 1 from F(2)
  fiboSum   = { 1, 1+1 };

  // find all Fibonacci number below 10^17
  while (fibonacci.back() < limit)
  {
    auto size = fibonacci.size();
    auto nextFibo = fibonacci[size - 1] + fibonacci[size - 2];
    fibonacci.push_back(nextFibo);

    // "special" sum of Fibonacci numbers
    auto nextSum  = fiboSum  [size - 1] + fiboSum  [size - 2] + fibonacci[size - 2] - 1;
    fiboSum.push_back(nextSum);
  }

  // NOT including 10^17
  limit--;
  // display result
  std::cout << search(limit) << std::endl;

  // my old test code for the first 100 numbers
  //auto sum = 0;
  //for (auto i = 1; i < 100; i++)
  //{
  //  auto current = zeckendorf(i);
  //  sum += current;
  //  std::cout << i << "=" << current << " " << sum << " / " << search(i) << std::endl;
  //}

  return 0;
}
